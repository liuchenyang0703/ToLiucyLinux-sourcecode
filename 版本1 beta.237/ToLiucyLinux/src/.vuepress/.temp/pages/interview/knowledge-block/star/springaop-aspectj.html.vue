<template><div><h1 id="springaop和aspectj有什么关系" tabindex="-1"><a class="header-anchor" href="#springaop和aspectj有什么关系" aria-hidden="true">#</a> SpringAOP和AspectJ有什么关系</h1>
<p>我们知道现在开发都是Spring，讲的最多的也是SpringAOP，在说springAOP前，先了解下AOP是什么？<br>
AOP是通过 “预编译方式” 和 “运行期间动态代理” 实现程序功能的统一维护的一种技术。AOP是一个概念，其实现技术有AspectJ和springAOP，现在对AOP有个清楚的了解了，再来看下AOP中的一些概念。</p>
<ol>
<li>切面（aspect）,业务层面是程序中的标准代码/功能，不同于实际的业务逻辑，比如日志功能、事务等。代码层面切点+通知构成了一个切面。</li>
<li>连接点（joinPoint），程序运行过程中的某个特定点，比如方法执行、字段赋值、方法调用等。</li>
<li>切点/切入点（pointCut），一个匹配连接点的正则表达式。 每当任何连接点匹配一个切入点时，就执行与该切入点相关联的通知。可以把切入点看作是符合条件的连接点。</li>
<li>通知（advice），在一个连接点中，切面采取的行动，简单点说是对切点做什么事，主要有before、afterReturning、round等通知。</li>
<li>织入（weaving），连接切面和目标对象来创建一个通知对象的过程，简单点说是把通知应用到连接点的过程。</li>
</ol>
<h3 id="基本概念" tabindex="-1"><a class="header-anchor" href="#基本概念" aria-hidden="true">#</a> 基本概念</h3>
<ul>
<li>Spring AOP：Spring AOP是Spring框架的一个模块，提供了面向切面编程的实现。它允许开发者定义横切关注点（cross-cutting concerns），比如日志、事务管理等，而不需要修改主业务逻辑代码。Spring AOP是通过代理方式实现的，它在运行时通过JDK动态代理或CGLIB代理为目标对象创建一个代理对象来实现横切逻辑的织入。</li>
<li>AspectJ：AspectJ是一个成熟的、功能完备的面向切面编程（AOP）框架，它不仅可以与Spring集成，还可以独立使用。AspectJ提供了比Spring AOP更为强大的切面功能，包括编译时织入、加载时织入等，允许在不同的编程生命周期阶段应用切面逻辑。</li>
</ul>
<h3 id="他们之间的关系" tabindex="-1"><a class="header-anchor" href="#他们之间的关系" aria-hidden="true">#</a> 他们之间的关系</h3>
<ul>
<li>互补性：Spring AOP和AspectJ在AOP领域是互补的。Spring AOP主要解决了企业应用中的常见问题，比如声明式事务和安全性，而AspectJ则提供了更为全面的AOP支持，包括那些Spring AOP无法处理的场景。</li>
<li>集成性：Spring AOP在内部可以集成AspectJ的某些功能。例如，Spring可以使用AspectJ的注解（比如@Aspect），并且Spring也支持AspectJ的编织方式（尽管默认情况下使用的是Spring AOP的代理方式）。这意味着我们程序员可以在Spring框架中使用AspectJ的强大功能，而不必完全依赖AspectJ。</li>
</ul>
<h3 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h3>
<ul>
<li>Spring AOP：适用于简单的AOP需求，如声明式事务管理、日志记录等。当AOP需求不是特别复杂，或者希望完全融入Spring生态系统时，Spring AOP是一个很好的选择。</li>
<li>AspectJ：适用于需要复杂AOP处理的场景，如需要在编译时就织入切面的场合。如果需要全面的AOP支持，或者要处理Spring AOP无法处理的切面织入，AspectJ是更合适的选择。</li>
</ul>
<h3 id="实现方式不同" tabindex="-1"><a class="header-anchor" href="#实现方式不同" aria-hidden="true">#</a> 实现方式不同</h3>
<ul>
<li>Spring AOP 使用代理的方式实现 AOP。Spring 利用 JDK 动态代理 或 CGLIB 代理创建代理对象，代理对象包装目标对象并拦截指定的切点方法，以执行通知。</li>
<li>AspectJ 支持两种方式实现 AOP。第一种方式是编译时织入，即在编译时将切面代码织入到目标类中。第二种方式是运行时织入，即在目标类加载时通过修改字节码方式织入切面代码。<br>
性能和能力</li>
<li>性能：由于AspectJ可以在编译时织入切面，因此它通常在运行时性能上优于Spring AOP。Spring AOP在运行时创建代理对象，这可能会引入一些性能开销。</li>
<li>能力：AspectJ提供了比Spring AOP更丰富的切面指令和织入选项，例如pointcut的表达能力更强，支持after、before、around等不同类型的通知，以及更精细的控制如within、call、execution等。</li>
</ul>
<p>我们知道现在开发都是Spring，讲的最多的也是SpringAOP，在说springAOP前，先了解下AOP是什么？<br>
AOP是通过 “预编译方式” 和 “运行期间动态代理” 实现程序功能的统一维护的一种技术。AOP是一个概念，其实现技术有AspectJ和springAOP，现在对AOP有个清楚的了解了，再来看下AOP中的一些概念。</p>
<ol>
<li>切面（aspect）,业务层面是程序中的标准代码/功能，不同于实际的业务逻辑，比如日志功能、事务等。代码层面切点+通知构成了一个切面。</li>
<li>连接点（joinPoint），程序运行过程中的某个特定点，比如方法执行、字段赋值、方法调用等。</li>
<li>切点/切入点（pointCut），一个匹配连接点的正则表达式。 每当任何连接点匹配一个切入点时，就执行与该切入点相关联的通知。可以把切入点看作是符合条件的连接点。</li>
<li>通知（advice），在一个连接点中，切面采取的行动，简单点说是对切点做什么事，主要有before、afterReturning、round等通知。</li>
<li>织入（weaving），连接切面和目标对象来创建一个通知对象的过程，简单点说是把通知应用到连接点的过程。</li>
</ol>
<h3 id="基本概念-1" tabindex="-1"><a class="header-anchor" href="#基本概念-1" aria-hidden="true">#</a> 基本概念</h3>
<ul>
<li>Spring AOP：Spring AOP是Spring框架的一个模块，提供了面向切面编程的实现。它允许开发者定义横切关注点（cross-cutting concerns），比如日志、事务管理等，而不需要修改主业务逻辑代码。Spring AOP是通过代理方式实现的，它在运行时通过JDK动态代理或CGLIB代理为目标对象创建一个代理对象来实现横切逻辑的织入。</li>
<li>AspectJ：AspectJ是一个成熟的、功能完备的面向切面编程（AOP）框架，它不仅可以与Spring集成，还可以独立使用。AspectJ提供了比Spring AOP更为强大的切面功能，包括编译时织入、加载时织入等，允许在不同的编程生命周期阶段应用切面逻辑。</li>
</ul>
<h3 id="他们之间的关系-1" tabindex="-1"><a class="header-anchor" href="#他们之间的关系-1" aria-hidden="true">#</a> 他们之间的关系</h3>
<ul>
<li>互补性：Spring AOP和AspectJ在AOP领域是互补的。Spring AOP主要解决了企业应用中的常见问题，比如声明式事务和安全性，而AspectJ则提供了更为全面的AOP支持，包括那些Spring AOP无法处理的场景。</li>
<li>集成性：Spring AOP在内部可以集成AspectJ的某些功能。例如，Spring可以使用AspectJ的注解（比如@Aspect），并且Spring也支持AspectJ的编织方式（尽管默认情况下使用的是Spring AOP的代理方式）。这意味着我们程序员可以在Spring框架中使用AspectJ的强大功能，而不必完全依赖AspectJ。</li>
</ul>
<h3 id="使用场景-1" tabindex="-1"><a class="header-anchor" href="#使用场景-1" aria-hidden="true">#</a> 使用场景</h3>
<ul>
<li>Spring AOP：适用于简单的AOP需求，如声明式事务管理、日志记录等。当AOP需求不是特别复杂，或者希望完全融入Spring生态系统时，Spring AOP是一个很好的选择。</li>
<li>AspectJ：适用于需要复杂AOP处理的场景，如需要在编译时就织入切面的场合。如果需要全面的AOP支持，或者要处理Spring AOP无法处理的切面织入，AspectJ是更合适的选择。</li>
</ul>
<h3 id="实现方式不同-1" tabindex="-1"><a class="header-anchor" href="#实现方式不同-1" aria-hidden="true">#</a> 实现方式不同</h3>
<ul>
<li>Spring AOP 使用代理的方式实现 AOP。Spring 利用 JDK 动态代理 或 CGLIB 代理创建代理对象，代理对象包装目标对象并拦截指定的切点方法，以执行通知。</li>
<li>AspectJ 支持两种方式实现 AOP。第一种方式是编译时织入，即在编译时将切面代码织入到目标类中。第二种方式是运行时织入，即在目标类加载时通过修改字节码方式织入切面代码。<br>
性能和能力</li>
<li>性能：由于AspectJ可以在编译时织入切面，因此它通常在运行时性能上优于Spring AOP。Spring AOP在运行时创建代理对象，这可能会引入一些性能开销。</li>
<li>能力：AspectJ提供了比Spring AOP更丰富的切面指令和织入选项，例如pointcut的表达能力更强，支持after、before、around等不同类型的通知，以及更精细的控制如within、call、execution等。</li>
</ul>
</div></template>


